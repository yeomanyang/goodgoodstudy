## 变量
JS不允许直接访问对象的内存空间，引用类型的访问是按引用访问的，但是在为对象添加属性的时候，操作的是实际的对象。JS中的字符串不同于其他语言，是基本类型，存储在栈内存。

复制一份引用对象，这个副本也指向同一个对象，两个变量操作对象都会互相影响。

#### 知识点！！！
ECMAScript中的所有函数的参数都是按值传递的。

这句话很容易引起误解，因为如下代码：


```

function setName(obj) {
    obj.name = 'yeoman';
}

let person = new Object();
setName(person);

console.log(person.name);

```

在修改了参数的name属性之后，会影响到外部的变量，这很容易让人误以为在JS中引用类型是按引用传递的。

### 求值策略

我们先需要讲清楚按值传递和按引用传递这两个概念，在计算机科学中都被称作求值策略，实际上除了这两种，还有一种常见的策略是按共享对象传递：

我们来看下这些[求值策略](https://zh.wikipedia.org/wiki/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5)的表现：

1. 传值调用 (Call by value)

在传值调用中实际参数被求值，其值被绑定到函数中对应的变量上（通常是把值复制到新内存区域)，也就是说在函数调用结束后，外部传给函数的任何东西都不会改变。

2. 传引用调用 (Call by reference)

在“传引用调用”求值中，传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。可以通过这个隐式引用去直接修改调用者的值。

可以理解成，传递的是指针。

3. 传共享对象调用（Call by sharing）

与传引用调用不同，对于调用者而言在被调用函数里修改参数是没有影响的。如果要达成传引用调用的效果就需要传一个共享对象，一旦被调用者修改了对象，调用者就可以看到变化（因为对象是共享的，没有拷贝）。

可以理解成，传递的是引用。

> 需要注意的是，引用和指针的区别，我理解引用和指针都是对内存地址的描述，但是引用是地址的别名，有点像受限的指针，只有访问权限而没有修改权限。


```

function setName1(obj) {
    obj.name = 'yeoman';
    obj = new Object();
    obj.name = 'nick';
}

let person1 = new Object();
setName(person1);

console.log(person1.name)

```

我们可以通过这个例子来推翻JS的引用类型是按引用传递的，因为我们直接给这个参数赋值，并不会影响外部的变量。

### 结论

所以更合适的描述是，JS中的基本类型是按值传递的，引用类型其实是按共享对象传递的。

### 类型检测

在上一章提到JS中判断数据类型可以通过`typeof`，但是对于Object类型中具体的Array，Date等对象的区别就需要通过`instanceof`来进行判断了

扩展：
> `instanceof`的本质是通过原型链一直往下去匹配，如下代码：

```
L instanceof R =>

` L.__proto__.__proto__ ..... === R.prototype`

```

## 执行环境与作用域链

简单概括：每个环境都可以向上搜索作用域链，但是不能通过向下搜索作用域链访问另一个环境的变量和函数。

==待深入研究：执行环境，作用域链，变量对象（VO），活动对象（AO）之间的关联。==

* with和catch会产生一个新的作用域

## 垃圾收集

JS中具有自动垃圾回收机制，大部分情况下不需要开发人员自己去管理内存回收。垃圾收集器会按照固定的时间间隔去进行内存回收。

目前所有的现代浏览器都已经采用标记清除来进行垃圾回收管理，而老版本IE对于DOM和BOM采用的是引用计数的回收方式。

引用计数存在的问题是，当存在循环引用的情况下，内存无法被释放，比如如下代码：


```

let element = document.getElementById('some_element');
let obj = new Object();
obj.element = element;
element.someObj = obj;

```

> 比较好的编码习惯：一旦全局对象不再需要使用，最好通过将其设为null来进行解除引用，这样垃圾回收器在下一次回收的时候就会对该变量进行回收。而局部变量会在他们离开执行环境之后自动解除。
